#include <iostream>


using namespace std;

template<typename T>
void print(T** source_dvumern, int image_width, int image_height)
	{
	for(int i=0; i<image_height; i++)
		{
		for(int j=0; j<image_width; j++)
			{
			cout<<(int)source_dvumern[i][j]<<"\t";
			}
		cout<< endl;
		}
	cout<< endl;
	}

// преобразование буфера в двумерный масссив
void Dvumern(uint8_t** target, uint8_t* source, int image_width, int image_height)
	{
	int i_s=0;
	for(int i=0; i<image_height; i++)
		for(int j=0; j<image_width; j++)
			{
			target[i][j]=source[i_s];
			i_s++;
			}
	}

// дополнение изображения на область куда попадает окно
void DopolnImage(int** target, uint8_t** source, int image_width, int image_height, int w_add, int h_add)
	{
	for(int i=0; i<h_add/2; i++)
		for(int j=0; j<image_width+w_add; j++)
			{
			target[i][j]=128;
			target[i+image_height+h_add/2][j]=128;
			}
	for(int i=h_add/2; i<image_height+h_add/2; i++)
		for(int j=0; j<w_add/2; j++)
			{
			target[i][j]=128;
			target[i][j+image_width+w_add/2]=128;
			}
	for(int i=0; i<image_height; i++)
		for(int j=0; j<image_width; j++)
			{
			target[i+h_add/2][j+w_add/2]=source[i][j];
			}
	}

// вычисление IntegralImage для последующего вычисления среднего и среднеквадратичного 
void IntegralImage(int** target, int** source, int image_width, int image_height, bool kvadrat)
	{
	for(int y=0; y<image_height; y++)
		{
		for(int x=0; x<image_width; x++)
			{
			//  I (x, y) = i (x, y) + I (x, y-1) + I (x-1, y) - I (x-1, y-1)

			//I (x, y-1)
			int x_ym1=128;
			if(y-1 >= 0) x_ym1=target[y-1][x];

			// I (x-1, y)
			int xm1_y=128;
			if(x-1 >= 0) xm1_y=target[y][x-1];

			// I (x-1, y-1)
			int xm1_ym1=128;
			if(x-1 >= 0 && y-1 >= 0) xm1_ym1=target[y-1][x-1];

			//  I (x, y) = i (x, y) + I (x, y-1) + I (x-1, y) - I (x-1, y-1)
			if(kvadrat) target[y][x] = (source[y][x] * source[y][x]) + x_ym1 + xm1_y - xm1_ym1;
				else target[y][x] = source[y][x] + x_ym1 + xm1_y - xm1_ym1;

			//if(target[y][x]==1066)
			//	cout<< x<<":"<<y << " " << target[y][x] << " = " << (int)source[y][x] << " + " << x_ym1 << " + " << xm1_y << " - " << xm1_ym1<<endl<<endl;
			}
		}
	}

// вычисление пороговых значений каждого пикселя
void Niblack_in(int** target, int** source, int** source2, int image_width, int image_height, int image_stride, int window_width, int window_height, double stdev_coeff)
	{
	int j_add=(window_width-1)/2;
	int i_add=(window_height-1)/2;
	int j_s;
	int i_s;
	for(int i=0; i<image_height; i++)
		{
		for(int j=0; j<image_width; j++)
			{
			j_s=j+j_add;
			i_s=i+i_add;
			//cout<< source2[i_s][j_s] << " : A=" << source2[i_s-i_add][j_s-j_add];
			//cout<<                        " B=" << source2[i_s-i_add][j_s+j_add];
			//cout<<                        " C=" << source2[i_s+i_add][j_s-j_add];
			//cout<<                        " D=" << source2[i_s+i_add][j_s+j_add]<<endl;
			// вычисление среднего
			int sredn = source[i_s+i_add][j_s+j_add] -
						source[i_s-i_add][j_s+j_add] -
						source[i_s+i_add][j_s-j_add] +
						source[i_s-i_add][j_s-j_add];

			// вычисление среднеквадратичного
			int sredn2 = source2[i_s+i_add][j_s+j_add] -
						 source2[i_s-i_add][j_s+j_add] -
						 source2[i_s+i_add][j_s-j_add] +
						 source2[i_s-i_add][j_s-j_add];

			//cout<< sredn << "\t";
			//cout<< sredn2 << "\t";

			//int korrekt=0;
			int korrekt=255;
			if(stdev_coeff>0) korrekt=-255;

			// вычисление пороговых значений
			target[i][j] = sredn + (stdev_coeff * sredn2) + korrekt;
			//cout<< target[j][i] << "\t";
			}
		//cout << endl;
		}
	}

void Niblack(uint8_t* target, uint8_t* source, int image_width, int image_height, int image_stride, int window_width, int window_height, double stdev_coeff)
	{
	uint8_t **source_dvumern=new uint8_t*[image_height];
	int  **target_dvumern=new int*[image_height];
	for(int i=0; i<image_height; i++)
		{
		source_dvumern[i]=new uint8_t[image_width];
		target_dvumern[i]=new int[image_width];
		}

	int h_add=(window_height-1);
	int w_add=(window_width-1);
	int height_added=image_height+h_add;
	int width_added=image_width+w_add;
	int **dopoln_image=new int*[height_added];
	int **integral_image=new int*[height_added];
	int **integral_image2=new int*[height_added];
	for(int i=0; i<height_added; i++)
		{
		dopoln_image[i]=new int[width_added];
		integral_image[i]=new int[width_added];
		integral_image2[i]=new int[width_added];
		}

	Dvumern(source_dvumern, source, image_width, image_height);
	// вывод исходного изображения
	cout<<"original image output:\n";
	print(source_dvumern, image_width, image_height);

	DopolnImage(dopoln_image, source_dvumern, image_width, image_height, w_add, h_add);
	// добавлены пиксели по краям
	cout<<"added pixels around the edges:\n";
	print(dopoln_image, width_added, height_added);


	IntegralImage(integral_image, dopoln_image, width_added, height_added, false);
	// Integral Image для среднего значения в окне
	cout<<"Integral Image for mean of the neighbourhood:\n";
	print(integral_image, width_added, height_added);

	IntegralImage(integral_image2, dopoln_image, width_added, height_added, true);
	// Integral Image для среднеквадратичного значения в окне
	cout<<"Integral Image for standard deviation of the neighbourhood:\n";
	print(integral_image2, width_added, height_added);

	Niblack_in(target_dvumern, integral_image, integral_image2, image_width, image_height, 0, window_width, window_height, stdev_coeff);
	// Пороговые значения каждого пикселя
	cout<<"The threshold value at each pixel:\n";
	print(target_dvumern, image_width, image_height);

	// пороговое отсечение
	int i_s=0;
	for(int i=0; i<image_height; i++)
		{
		for(int j=0; j<image_width; j++)
			{
			if(source[i_s] < target_dvumern[i][j]) target[i_s]=0;
				else target[i_s]=255;
			i_s++;
			}
		}

	for(int i=0; i<height_added; i++)
		{
		delete []dopoln_image[i];
		delete []integral_image[i];
		delete []integral_image2[i];
		}

	for(int i=0; i<image_height; i++)
		{
		delete []source_dvumern[i];
		delete []target_dvumern[i];
		}

	delete []dopoln_image;
	delete []integral_image;
	delete []integral_image2;
	delete []source_dvumern;
	delete []target_dvumern;
	}

int main()
{
	int image_width=7, image_height=15;
	int window_width=3, window_height=3;
	int coutn_pix=image_width*image_height;
	double stdev_coeff = - 0.2;

	uint8_t *source=new uint8_t [coutn_pix];
	uint8_t *target=new uint8_t [coutn_pix];

	// заполнение исходного изображения случайными данными (в середине темная область)
	for(int i=0; i<coutn_pix; i++)
		{
		source[i]=std::rand()%255;
		if(i > coutn_pix/3 && i < coutn_pix/1.4) source[i]=source[i]/20;
		}

	//for(int i=0; i<coutn_pix; i++) cout<< (int)source[i] << " ";
	//cout << endl << endl;

	// биниризация
	Niblack(target, source, image_width, image_height, 0, window_width, window_height, stdev_coeff);

	// вывод бинаризованного изображения
	cout<<"binarized image output:\n";
	int i_s=0;
	for(int i=0; i<image_height; i++)
		{
		for(int j=0; j<image_width; j++)
			{
			cout<<(int)target[i_s]<<"\t";
			i_s++;
			}
		cout << endl;
		}
	cout << endl;

	delete []source;
	delete []target;

	return 0;
}
